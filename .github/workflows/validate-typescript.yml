name: Validate TypeScript Compilation

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'src/**/*.ts'
      - 'src/**/*.tsx'
      - 'tsconfig.json'
      - 'package.json'
      - 'scripts/validate-typescript.js'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'src/**/*.ts'
      - 'src/**/*.tsx'
      - 'tsconfig.json'
      - 'package.json'
      - 'scripts/validate-typescript.js'

jobs:
  validate-typescript:
    name: Validate TypeScript
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Validate TypeScript configuration
      run: |
        echo "‚öôÔ∏è Validating TypeScript configuration..."
        node -e "
        const fs = require('fs');
        
        try {
          if (!fs.existsSync('tsconfig.json')) {
            console.log('‚ùå Missing tsconfig.json');
            process.exit(1);
          }
          
          const tsconfig = JSON.parse(fs.readFileSync('tsconfig.json', 'utf8'));
          console.log('‚úÖ tsconfig.json found and valid JSON');
          
          // Check key TypeScript configuration options
          const compilerOptions = tsconfig.compilerOptions || {};
          
          const importantOptions = {
            'strict': compilerOptions.strict,
            'target': compilerOptions.target,
            'module': compilerOptions.module,
            'moduleResolution': compilerOptions.moduleResolution,
            'esModuleInterop': compilerOptions.esModuleInterop,
            'skipLibCheck': compilerOptions.skipLibCheck,
            'jsx': compilerOptions.jsx
          };
          
          console.log('\\nüìã TypeScript Configuration:');
          Object.entries(importantOptions).forEach(([option, value]) => {
            console.log(\`  \${value !== undefined ? '‚úÖ' : '‚ÑπÔ∏è'} \${option}: \${value || 'not set'}\`);
          });
          
          // Check include/exclude patterns
          if (tsconfig.include) {
            console.log(\`\\nüìÅ Include patterns: \${tsconfig.include.join(', ')}\`);
          }
          if (tsconfig.exclude) {
            console.log(\`üìÅ Exclude patterns: \${tsconfig.exclude.join(', ')}\`);
          }
          
          console.log('üéâ TypeScript configuration validation completed!');
          
        } catch (error) {
          console.error('‚ùå TypeScript configuration validation failed:', error.message);
          process.exit(1);
        }
        "

    - name: Run TypeScript type checking
      run: |
        echo "üîç Running TypeScript type checking..."
        npm run type-check

    - name: Count TypeScript files
      run: |
        echo "üìä Analyzing TypeScript codebase..."
        node -e "
        const fs = require('fs');
        const path = require('path');
        
        function countTsFiles(dir, stats = { ts: 0, tsx: 0, js: 0, jsx: 0, total: 0 }) {
          try {
            const files = fs.readdirSync(dir);
            
            for (const file of files) {
              const fullPath = path.join(dir, file);
              const stat = fs.statSync(fullPath);
              
              if (stat.isDirectory() && !file.startsWith('.') && file !== 'node_modules' && file !== 'build') {
                countTsFiles(fullPath, stats);
              } else if (stat.isFile()) {
                const ext = path.extname(file);
                stats.total++;
                
                switch (ext) {
                  case '.ts':
                    stats.ts++;
                    break;
                  case '.tsx':
                    stats.tsx++;
                    break;
                  case '.js':
                    stats.js++;
                    break;
                  case '.jsx':
                    stats.jsx++;
                    break;
                }
              }
            }
          } catch (error) {
            // Skip inaccessible directories
          }
          
          return stats;
        }
        
        const stats = countTsFiles('src');
        
        console.log('üìà Codebase Statistics:');
        console.log(\`  TypeScript files (.ts): \${stats.ts}\`);
        console.log(\`  React TypeScript files (.tsx): \${stats.tsx}\`);
        console.log(\`  JavaScript files (.js): \${stats.js}\`);
        console.log(\`  React JavaScript files (.jsx): \${stats.jsx}\`);
        console.log(\`  Total source files: \${stats.total}\`);
        
        const tsPercentage = ((stats.ts + stats.tsx) / (stats.ts + stats.tsx + stats.js + stats.jsx)) * 100;
        console.log(\`\\nüìä TypeScript coverage: \${tsPercentage.toFixed(1)}%\`);
        
        if (tsPercentage >= 90) {
          console.log('üéâ Excellent TypeScript coverage!');
        } else if (tsPercentage >= 70) {
          console.log('‚úÖ Good TypeScript coverage');
        } else if (tsPercentage >= 50) {
          console.log('‚ö†Ô∏è Moderate TypeScript coverage');
        } else {
          console.log('‚ùå Low TypeScript coverage - consider migrating more files');
        }
        "

    - name: Check for TypeScript-specific patterns
      run: |
        echo "üî¨ Checking TypeScript patterns..."
        node -e "
        const fs = require('fs');
        const path = require('path');
        
        function analyzeTypeScriptUsage(dir) {
          const patterns = {
            interfaces: 0,
            types: 0,
            generics: 0,
            enums: 0,
            strictNullChecks: 0,
            optionalChaining: 0,
            nullishCoalescing: 0
          };
          
          function scanFile(filePath) {
            try {
              const content = fs.readFileSync(filePath, 'utf8');
              
              // Count TypeScript patterns
              patterns.interfaces += (content.match(/interface\s+\w+/g) || []).length;
              patterns.types += (content.match(/type\s+\w+/g) || []).length;
              patterns.generics += (content.match(/<[A-Z]\w*>/g) || []).length;
              patterns.enums += (content.match(/enum\s+\w+/g) || []).length;
              patterns.strictNullChecks += (content.match(/\|\s*null|\|\s*undefined/g) || []).length;
              patterns.optionalChaining += (content.match(/\?\./g) || []).length;
              patterns.nullishCoalescing += (content.match(/\?\?/g) || []).length;
              
            } catch (error) {
              // Skip files that can't be read
            }
          }
          
          function scanDirectory(dirPath) {
            try {
              const files = fs.readdirSync(dirPath);
              
              for (const file of files) {
                const fullPath = path.join(dirPath, file);
                const stat = fs.statSync(fullPath);
                
                if (stat.isDirectory() && !file.startsWith('.') && file !== 'node_modules') {
                  scanDirectory(fullPath);
                } else if (stat.isFile() && (file.endsWith('.ts') || file.endsWith('.tsx'))) {
                  scanFile(fullPath);
                }
              }
            } catch (error) {
              // Skip inaccessible directories
            }
          }
          
          scanDirectory(dir);
          return patterns;
        }
        
        const patterns = analyzeTypeScriptUsage('src');
        
        console.log('üîç TypeScript Pattern Usage:');
        console.log(\`  Interfaces: \${patterns.interfaces}\`);
        console.log(\`  Type aliases: \${patterns.types}\`);
        console.log(\`  Generics usage: \${patterns.generics}\`);
        console.log(\`  Enums: \${patterns.enums}\`);
        console.log(\`  Strict null checks: \${patterns.strictNullChecks}\`);
        console.log(\`  Optional chaining (?.): \${patterns.optionalChaining}\`);
        console.log(\`  Nullish coalescing (??): \${patterns.nullishCoalescing}\`);
        
        const totalAdvancedFeatures = patterns.interfaces + patterns.types + patterns.generics + patterns.enums;
        
        if (totalAdvancedFeatures > 20) {
          console.log('\\nüéâ Excellent use of TypeScript features!');
        } else if (totalAdvancedFeatures > 10) {
          console.log('\\n‚úÖ Good use of TypeScript features');
        } else if (totalAdvancedFeatures > 5) {
          console.log('\\n‚ö†Ô∏è Moderate use of TypeScript features');
        } else {
          console.log('\\nüìù Consider using more TypeScript features for better type safety');
        }
        "

    - name: Check for common TypeScript issues
      run: |
        echo "üö® Checking for common TypeScript issues..."
        node -e "
        const fs = require('fs');
        const path = require('path');
        
        function scanForIssues(dir) {
          const issues = {
            anyUsage: 0,
            nonNullAssertion: 0,
            tsIgnore: 0,
            implicitAny: 0,
            unusedVars: 0
          };
          
          function scanFile(filePath) {
            try {
              const content = fs.readFileSync(filePath, 'utf8');
              const lines = content.split('\\n');
              
              lines.forEach((line, index) => {
                // Check for 'any' type usage
                if (line.includes(': any') || line.includes('<any>') || line.includes('any[]')) {
                  issues.anyUsage++;
                }
                
                // Check for non-null assertion operator
                if (line.includes('!.') || line.includes('!')&& !line.includes('!=') && !line.includes('!==')) {
                  issues.nonNullAssertion++;
                }
                
                // Check for @ts-ignore
                if (line.includes('@ts-ignore') || line.includes('@ts-nocheck')) {
                  issues.tsIgnore++;
                }
                
                // Check for potential implicit any (function parameters without types)
                if (line.match(/function\\s+\\w+\\s*\\([^)]*[a-zA-Z_]\\w*\\s*[,)]/)) {
                  if (!line.includes(':')) {
                    issues.implicitAny++;
                  }
                }
                
                // Check for unused variables (basic pattern)
                if (line.match(/^\\s*(const|let|var)\\s+\\w+/) && !content.includes(line.match(/\\w+/)[0])) {
                  issues.unusedVars++;
                }
              });
              
            } catch (error) {
              // Skip files that can't be read
            }
          }
          
          function scanDirectory(dirPath) {
            try {
              const files = fs.readdirSync(dirPath);
              
              for (const file of files) {
                const fullPath = path.join(dirPath, file);
                const stat = fs.statSync(fullPath);
                
                if (stat.isDirectory() && !file.startsWith('.') && file !== 'node_modules') {
                  scanDirectory(fullPath);
                } else if (stat.isFile() && (file.endsWith('.ts') || file.endsWith('.tsx'))) {
                  scanFile(fullPath);
                }
              }
            } catch (error) {
              // Skip inaccessible directories
            }
          }
          
          scanDirectory(dir);
          return issues;
        }
        
        const issues = scanForIssues('src');
        
        console.log('‚ö†Ô∏è Potential TypeScript Issues:');
        console.log(\`  'any' type usage: \${issues.anyUsage}\`);
        console.log(\`  Non-null assertions (!): \${issues.nonNullAssertion}\`);
        console.log(\`  @ts-ignore comments: \${issues.tsIgnore}\`);
        console.log(\`  Potential implicit any: \${issues.implicitAny}\`);
        
        const totalIssues = Object.values(issues).reduce((sum, count) => sum + count, 0);
        
        if (totalIssues === 0) {
          console.log('\\nüéâ No obvious TypeScript issues found!');
        } else if (totalIssues < 10) {
          console.log('\\n‚úÖ Few TypeScript issues - codebase looks good');
        } else if (totalIssues < 25) {
          console.log('\\n‚ö†Ô∏è Some TypeScript issues found - consider addressing them');
        } else {
          console.log('\\n‚ùå Many TypeScript issues found - code quality needs improvement');
        }
        "

    - name: Validate build compilation
      run: |
        echo "üèóÔ∏è Testing build compilation..."
        npm run build
        
        # Check if build completed successfully
        if [[ -d "build" ]]; then
          echo "‚úÖ Build completed successfully"
          
          # Check build size
          BUILD_SIZE=$(du -sh build 2>/dev/null | cut -f1 || echo "unknown")
          echo "üìè Build size: $BUILD_SIZE"
          
          # Check for TypeScript compilation artifacts
          if find build -name "*.js" -type f | head -1 | read; then
            echo "‚úÖ JavaScript files generated from TypeScript"
          else
            echo "‚ö†Ô∏è No JavaScript files found in build"
          fi
        else
          echo "‚ùå Build failed"
          exit 1
        fi

    - name: Generate TypeScript validation report
      if: always()
      run: |
        echo "## üîß TypeScript Validation Report" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Compilation Status" >> $GITHUB_STEP_SUMMARY
        
        node -e "
        const fs = require('fs');
        const path = require('path');
        
        try {
          // Count TypeScript files
          function countFiles(dir, exts) {
            let count = 0;
            try {
              const files = fs.readdirSync(dir);
              for (const file of files) {
                const fullPath = path.join(dir, file);
                const stat = fs.statSync(fullPath);
                if (stat.isDirectory() && !file.startsWith('.') && file !== 'node_modules') {
                  count += countFiles(fullPath, exts);
                } else if (stat.isFile() && exts.some(ext => file.endsWith(ext))) {
                  count++;
                }
              }
            } catch (error) {
              // Skip inaccessible directories
            }
            return count;
          }
          
          const tsFiles = countFiles('src', ['.ts', '.tsx']);
          const hasConfig = fs.existsSync('tsconfig.json');
          const hasBuild = fs.existsSync('build');
          
          console.log('| Metric | Value | Status |');
          console.log('|--------|-------|--------|');
          console.log(\`| TypeScript Files | \${tsFiles} | ‚úÖ |\\`);
          console.log(\`| Configuration | \${hasConfig ? 'Present' : 'Missing'} | \${hasConfig ? '‚úÖ' : '‚ùå'} |\\`);
          console.log(\`| Build Output | \${hasBuild ? 'Generated' : 'Missing'} | \${hasBuild ? '‚úÖ' : '‚ùå'} |\\`);
          console.log(\`| Compilation | Successful | ‚úÖ |\\`);
          
        } catch (error) {
          console.log('| Error | Validation Failed | ‚ùå |');
        }
        " >> $GITHUB_STEP_SUMMARY

    - name: Upload TypeScript validation artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: typescript-validation-report
        path: |
          tsconfig.json
          build/**/*.js
        retention-days: 30